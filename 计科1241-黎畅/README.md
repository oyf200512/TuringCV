## 创建画布以及画图
- 使用`canvas = np.ones((800,800,3),np.uint8)*255`创建一个800*800的白色画布

- 使用`circle、rectangle...`等函数绘制几何图形

---

## 边缘检测和计数
- 先copy一份原图，为下一步做准备

- 将图像转换为灰度图以简化计算和提升边缘检测效果
  *毕竟边缘检测用不到色彩信息*

- 使用`cv2.Canny()`函数检测灰度图的边缘

- 接着将上一步得到的结果用`cv2.findContours()`函数进行轮廓检测，并在copy下来的图片中使用`cv2.drawContours()`函数画出轮廓

- 同时`len(contours)`即为图形数量

---

## 模板检测
*随便选一个图像作为模板，这里选了紫色实心三角形*
- 再copy一份原图并进行切片可得模板图像

- 使用`cv2.matchTemplate()`函数检测相似度最高的地方

- 接着找出最大值：`cv2.minMaxLoc(result)`
*本来想用`loc = np.where(result >= 0.8)`来找出所有相似的点的，但会造成大量框框重叠，难以战胜QAQ*

- 在copy下来的图像画矩形框出对应三角形，并进行标注

---

最后是展示上述所有图片的代码
